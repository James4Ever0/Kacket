{
    "summary": "The Kacket language parser identifies syntax, supports functions and parentheses, and includes parsing functions for let-expressions, letrec-expressions, if expressions, and \"define\" syntax sugar.",
    "details": [
        {
            "comment": "This code defines a Parser class that takes a Lexer as input and has methods to check if the next token is an end, add SExprExtParser, check if the token is a right or left parenthesis, and throw ParseError if it should be a specific type of token. It also maintains lists of reserved words and SExprExtParsers.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":0-31",
            "content": "package com.github.std.kacket.parse\nimport com.github.std.kacket.expr.*\nimport com.github.std.kacket.parse.exten.SExprExtParser\nclass Parser(\n    private val lexer: Lexer\n) {\n    private val sExprExts = mutableListOf<SExprExtParser>()\n    private val reservedWords = mutableListOf(\"define\", \"if\", \"else\", \"let\", \"letrec\", \"let*\", \"cond\", \"lambda\")\n    fun isEnd(): Boolean = lexer.peekToken() is EOF\n    fun addSExprExt(ext: SExprExtParser): Parser {\n        reservedWords.add(ext.start())\n        sExprExts.add(ext)\n        return this\n    }\n    fun isRightParenthesis(token: Token): Boolean = token is Punctuation && token.isRightParenthesis()\n    fun isLeftParenthesis(token: Token): Boolean = token is Punctuation && token.isLeftParenthesis()\n    fun shouldBeLeftParenthesis(token: Token) {\n        if (!(isLeftParenthesis(token))) {\n            throw ParseError(token)\n        }\n    }\n    fun shouldBeRightParenthesis(token: Token) {\n        if (!(isRightParenthesis(token))) {\n            throw ParseError(token)\n        }"
        },
        {
            "comment": "This code defines a `parseExpr` function that parses expressions in Kacket language. It checks the token type and returns corresponding expression objects like `Var`, `Const`, or throws a `ParseError` for invalid input. It also includes functions to parse other expression types such as `parseSExpr`, `parseQuote`.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":32-67",
            "content": "    }\n    fun shouldBeNameToken(token: Token) {\n        if (token !is Identifier || reservedWords.contains(token.value)) {\n            throw ParseError(token)\n        }\n    }\n    fun parseExpr(): Expression {\n        val token = lexer.nextToken()\n        return when {\n            token is Identifier && !isReservedWord(token.value) -> {\n                Var(token)\n            }\n            token is Character || token is Bool || token is Num || token is Symbol || token is Text -> {\n                Const(token)\n            }\n            isLeftParenthesis(token) -> {\n                parseSExpr(token.lineNumber(), token.columnNumber())\n            }\n            token is Punctuation && token.char == '\\'' -> {\n                parseQuote(token.lineNumber(), token.columnNumber())\n            }\n            else -> {\n                throw ParseError(token)\n            }\n        }\n    }\n    private fun parseQuote(lineNumber: Int, columnNumber: Int): Quote {\n        val start = lexer.nextToken()\n//        shouldBeLeftParenthesis(start)"
        },
        {
            "comment": "The code parses a quote element in Kacket language. It checks the token type and creates different QuoteElement instances based on the token. If the token is a Punctuation with a single quote, it recursively calls parseQuote to handle nested quotes. The process continues until a right parenthesis is encountered.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":69-94",
            "content": "        val elements = mutableListOf<Quote.QuoteElement>()\n        var token = lexer.nextToken()\n        while (!(isRightParenthesis(token))) {\n            elements.add(parseQuoteElement(token))\n            token = lexer.nextToken()\n        }\n        shouldBeRightParenthesis(token)\n        return Quote(lineNumber, columnNumber, elements)\n    }\n    private fun parseQuoteElement(token: Token): Quote.QuoteElement {\n        return when {\n            token is Character || token is Bool || token is Num || token is Identifier || token is Symbol || token is Text -> {\n                Quote.ElementConst(token)\n            }\n            token is Punctuation && token.char == '\\'' -> {\n                Quote.ElementQuote(parseQuote(token.lineNumber(), token.columnNumber()))\n            }\n            isLeftParenthesis(token) -> {\n                val elements = mutableListOf<Quote.QuoteElement>()\n                var next = lexer.nextToken()\n                while (!(isRightParenthesis(next))) {\n                    elements.add(parseQuoteElement(next))"
        },
        {
            "comment": "This code is a parser for a programming language. It identifies different syntax elements and creates corresponding expressions based on the type of token encountered. The code handles various keyword identifiers such as 'define', 'if', 'let', 'lambda', 'letrec', 'let*', and 'cond'. If an unexpected token is encountered, it throws a ParseError.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":95-115",
            "content": "                    next = lexer.nextToken()\n                }\n                shouldBeRightParenthesis(next)\n                Quote.ElementQuotes(elements)\n            }\n            else -> throw ParseError(token)\n        }\n    }\n    private fun parseSExpr(line: Int, column: Int): Expression {\n        val token = lexer.nextToken()\n        val result = when {\n            token is Identifier && token.value == \"define\" -> parseDefine(line, column)\n            token is Identifier && token.value == \"if\" -> parseIf(line, column)\n            token is Identifier && token.value == \"let\" -> parseLet(line, column)\n            token is Identifier && token.value == \"lambda\" -> parseProc(line, column)\n            token is Identifier && token.value == \"letrec\" -> parseLetrec(line, column)\n            token is Identifier && token.value == \"let*\" -> parseLetstar(line, column)\n            token is Identifier && token.value == \"cond\" -> parseCond(line, column)\n            token is Identifier && token.value == \"begin\" -> parseBegin(line, column)"
        },
        {
            "comment": "This code snippet defines a parser for Kacket language. It parses different types of tokens and handles function calls, parentheses, and begin statements. The parseBegin() method recursively adds expressions within the parentheses until it encounters the right parenthesis. The reserved words are checked in the isReservedWord() method.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":116-146",
            "content": "            token is Identifier -> {\n                val ext = sExprExts.find { it.start() == token.value }\n                ext?.parse(lexer, line, column, this) ?: parseCall(token, line, column)\n            }\n            isLeftParenthesis(token) -> parseCall(token, line, column)\n            else -> throw ParseError(token)\n        }\n        shouldBeRightParenthesis(lexer.nextToken())\n        return result\n    }\n    private fun parseBegin(line: Int, column: Int): Begin {\n        var peek = lexer.peekToken()\n        val body = mutableListOf<Expression>()\n        while (!(isRightParenthesis(peek))) {\n            body.add(parseExpr())\n            peek = lexer.peekToken()\n        }\n        return Begin(body, line, column)\n    }\n    private fun isReservedWord(id: String): Boolean =\n        reservedWords.contains(id)\n    private fun parseCall(token: Token, line: Int, column: Int): Expression {\n        fun parseArgs(): List<Expression> {\n            val args = mutableListOf<Expression>()\n            var peek = lexer.peekToken()"
        },
        {
            "comment": "The code above is parsing a language that supports function calls and letrec declarations. It checks for parentheses, identifiers, or S-expressions and handles them accordingly. If a syntax error occurs, it throws a ParseError. The parseLetrec method creates lists of variables and values for the letrec declaration.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":147-177",
            "content": "            while (!(isRightParenthesis(peek))) {\n                args.add(parseExpr())\n                peek = lexer.peekToken()\n            }\n            return args\n        }\n        return when {\n            isLeftParenthesis(token) -> {\n                val proc = parseSExpr(token.lineNumber(), token.columnNumber())\n                val args = parseArgs()\n                Call(proc, args, line, column)\n            }\n            token is Identifier && !isReservedWord(token.value) -> {\n                val proc = Var(token)\n                val args = parseArgs()\n                Call(proc, args, line, column)\n            }\n            else -> {\n                val msg =\n                    \"Syntax Error at(${token.lineNumber()}, ${token.columnNumber()}), expect an Identifier or S-Expression\"\n                throw ParseError(msg)\n            }\n        }\n    }\n    private fun parseLetrec(line: Int, column: Int): Expression {\n        val variables = mutableListOf<String>()\n        val values = mutableListOf<Expression>()"
        },
        {
            "comment": "This code parses let expressions with recursive binding in Kacket programming language. It defines a function for parsing a single let pair, and another for parsing multiple let pairs within parentheses. The parseLetPairs function is called first to handle cases with multiple let pairs.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":178-212",
            "content": "        parseLetPairs(variables, values)\n        val body = mutableListOf<Expression>()\n        parseLetBody(body)\n        return Letrec(variables, values, body, line, column)\n    }\n    private fun parseLetPair(variables: MutableList<String>, values: MutableList<Expression>) {\n        shouldBeLeftParenthesis(lexer.nextToken())\n        val id = lexer.nextToken()\n        if (id !is Identifier || isReservedWord(id.value)) {\n            throw ParseError(id)\n        }\n        variables.add(id.value)\n        val value = parseExpr()\n        values.add(value)\n        shouldBeRightParenthesis(lexer.nextToken())\n    }\n    private fun parseLetPairs(variables: MutableList<String>, values: MutableList<Expression>) {\n        shouldBeLeftParenthesis(lexer.nextToken())\n//        parseLetPair(variables, values)\n        var peek = lexer.peekToken()\n        while (isLeftParenthesis(peek)) {\n            parseLetPair(variables, values)\n            peek = lexer.peekToken()\n        }\n        shouldBeRightParenthesis(lexer.nextToken())"
        },
        {
            "comment": "This code defines functions for parsing Let statements in the Kacket programming language. The parseLetBody function adds expressions to a list until a right parenthesis is encountered. The parseNormalLet and parseNamedLet functions parse normal and named Lets, respectively, by creating lists of variable names and values, then adding a body using the parseLetBody function before returning a Let expression object with the provided line and column information.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":213-247",
            "content": "    }\n    private fun parseLetBody(body: MutableList<Expression>) {\n        body.add(parseExpr())\n        var peek = lexer.peekToken()\n        while (!(isRightParenthesis(peek))) {\n            body.add(parseExpr())\n            peek = lexer.peekToken()\n        }\n    }\n    private fun parseNormalLet(line: Int, column: Int): Expression {\n        val variables = mutableListOf<String>()\n        val values = mutableListOf<Expression>()\n        parseLetPairs(variables, values)\n        val body = mutableListOf<Expression>()\n        parseLetBody(body)\n        return Let(variables, values, body, line, column)\n    }\n    private fun parseNamedLet(line: Int, column: Int): Expression {\n        val token = lexer.nextToken()\n        if (token !is Identifier || isReservedWord(token.value)) {\n            throw ParseError(\"Invalid Let near ($line, $column)\")\n        }\n        val procArgs = mutableListOf<String>()\n        val values = mutableListOf<Expression>()\n        parseLetPairs(procArgs, values)\n        val procBody = mutableListOf<Expression>()"
        },
        {
            "comment": "The code defines a function for parsing let-expressions and letrec-expressions. It creates a list of variables and values, then uses these to create either a Let or Letrec expression, depending on whether there are any variables or values present. If there are no variables or values, it returns a Let expression; otherwise, it constructs a Letrec expression by adding the previous let as a value for each variable in reverse order.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":248-278",
            "content": "        parseLetBody(procBody)\n        val proc = Procedure(procArgs, procBody, line, column)\n        val letrecBody: List<Expression> = listOf(Call(Var(token), values, line, column))\n        return Letrec(\n            listOf(token.value), listOf(proc), letrecBody, line, column\n        )\n    }\n    private fun parseLetstar(line: Int, column: Int): Expression {\n        val variables = mutableListOf<String>()\n        val values = mutableListOf<Expression>()\n        parseLetPairs(variables, values)\n        val body = mutableListOf<Expression>()\n        parseLetBody(body)\n        if (variables.isEmpty() && values.isEmpty()) {\n            return Let(variables, values, body, line, column)\n        }\n        var index = variables.size - 1\n        var let = Let(\n            listOf(variables[index]), listOf(values[index]), body, line, column\n        )\n        while (index > 0) {\n            index--\n            let = Let(\n                listOf(variables[index]), listOf(values[index]), listOf(let), line, column\n            )"
        },
        {
            "comment": "The code defines two private functions: parseLet and parseProc. parseLet determines whether the line contains a named or normal Let statement and returns an Expression accordingly. If it is a named Let, the function calls parseNamedLet; if it's a normal Let, it calls parseNormalLet. The parseProc function parses proc statements, ensuring that the correct parentheses are used and storing arguments in a list before returning an Expression.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":279-316",
            "content": "        }\n        return let\n    }\n    private fun parseLet(line: Int, column: Int): Expression {\n        val token = lexer.peekToken()\n        return when {\n            isLeftParenthesis(token) -> {\n                parseNormalLet(line, column)\n            }\n            token is Identifier && !isReservedWord(token.value) -> {\n                parseNamedLet(line, column)\n            }\n            else -> throw ParseError(\"Invalid Let near ($line, $column)\")\n        }\n    }\n    private fun parseProc(line: Int, column: Int): Expression {\n        val start = lexer.nextToken()\n        shouldBeLeftParenthesis(start)\n        val args = mutableListOf<String>()\n        var peek = lexer.peekToken()\n        while (!(isRightParenthesis(peek))) {\n            val id = lexer.nextToken()\n            if (id !is Identifier || isReservedWord(id.value)) {\n                throw ParseError(id)\n            }\n            args.add(id.value)\n            peek = lexer.peekToken()\n        }\n        val endOfArgs = lexer.nextToken()\n        shouldBeRightParenthesis(endOfArgs)"
        },
        {
            "comment": "This code snippet defines a function that parses a conditional expression and returns an If expression. The parseCond function utilizes the buildIf helper function to construct the If expression using a list of conditions (preds) and their corresponding values (values), with an optional default expression if no condition matches.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":318-343",
            "content": "        val body = mutableListOf<Expression>()\n        body.add(parseExpr())\n        peek = lexer.peekToken()\n        while (!(isRightParenthesis(peek))) {\n            body.add(parseExpr())\n            peek = lexer.peekToken()\n        }\n        return Procedure(args, body, line, column)\n    }\n    private fun parseCond(line: Int, column: Int): Expression {\n        fun buildIf(preds: MutableList<Expression>, values: MutableList<Expression>, default: Expression): Expression {\n            if (preds.isEmpty() && values.isEmpty()) {\n                return default\n            }\n            var index = preds.size - 1\n            var innerIf = If(preds[index], values[index], default, line, column)\n            while (index > 0) {\n                index--\n                innerIf = If(preds[index], values[index], innerIf, line, column)\n            }\n            return innerIf\n        }\n        fun buildIf(preds: MutableList<Expression>, values: MutableList<Expression>): Expression {\n            // TODO: what is the ALTER of last IF?"
        },
        {
            "comment": "This code defines a function \"parseIf\" that parses an if expression in the source code. It checks for empty conditions and values, then constructs an if statement by iteratively parsing conditions and corresponding values until it reaches a right parenthesis. If an \"else\" is encountered, the else clause along with its expression is parsed separately. Finally, it returns the parsed if statement or expression as per the code structure.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":344-373",
            "content": "            if (preds.isEmpty() && values.isEmpty()) {\n                return Quote.NIL\n            }\n            return buildIf(preds, values, Quote.NIL)\n        }\n        val preds = mutableListOf<Expression>()\n        val values = mutableListOf<Expression>()\n        var peek = lexer.peekToken()\n        while (!isRightParenthesis(peek)) {\n            shouldBeLeftParenthesis(lexer.nextToken())\n            val next = lexer.peekToken()\n            if (next is Identifier && next.value == \"else\") {\n                lexer.nextToken()\n                val default = parseExpr()\n                shouldBeRightParenthesis(lexer.nextToken())\n                return buildIf(preds, values, default)\n            } else {\n                preds.add(parseExpr())\n                values.add(parseExpr())\n                shouldBeRightParenthesis(lexer.nextToken())\n            }\n            peek = lexer.peekToken()\n        }\n        return buildIf(preds, values)\n    }\n    private fun parseIf(line: Int, column: Int): Expression {\n        val pred = parseExpr()"
        },
        {
            "comment": "This code defines a function to parse the \"define\" syntax sugar in a programming language. It expects an expression as input and returns another expression as output, which represents the definition. The code checks if the name is valid, collects arguments, confirms the closing parenthesis, and parses the body of the define statement.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":374-403",
            "content": "        val conseq = parseExpr()\n        val alter = parseExpr()\n        return If(pred, conseq, alter, line, column)\n    }\n    private fun parseDefine(line: Int, column: Int): Expression {\n        fun parseProcSyntaxSugarDefine(): Expression {\n            val name = lexer.nextToken()\n            if (name !is Identifier || isReservedWord(name.value)) {\n                throw ParseError(name)\n            }\n            val args = mutableListOf<String>()\n            var peek = lexer.peekToken()\n            while (!(isRightParenthesis(peek))) {\n                val id = lexer.nextToken()\n                if (id !is Identifier || isReservedWord(id.value)) {\n                    throw ParseError(id)\n                }\n                args.add(id.value)\n                peek = lexer.peekToken()\n            }\n            val endOfArgs = lexer.nextToken()\n            shouldBeRightParenthesis(endOfArgs)\n            val body = mutableListOf<Expression>()\n            body.add(parseExpr())\n            peek = lexer.peekToken()\n            while (!(isRightParenthesis(peek))) {"
        },
        {
            "comment": "This code parses a define statement in a programming language and returns the result. It first checks if the token is a left parenthesis, identifier not reserved word, or anything else (throws an error). If it's an identifier not a reserved word, it calls parseIdDefine(). If it's a left parenthesis, it calls parseProcSyntaxSugarDefine(). It adds the result to body and returns Define.",
            "location": "\"/media/root/Toshiba XG3/works/Kacket/docs/src/src/main/kotlin/com/github/std/kacket/parse/Parser.kt\":404-427",
            "content": "                body.add(parseExpr())\n                peek = lexer.peekToken()\n            }\n            return Define(name.value, Procedure(args, body, line, column), line, column)\n        }\n        fun parseIdDefine(id: Identifier): Expression {\n            return Define(id.value, parseExpr(), line, column)\n        }\n        val token = lexer.nextToken()\n        return when {\n            isLeftParenthesis(token) -> {\n                parseProcSyntaxSugarDefine()\n            }\n            token is Identifier && !isReservedWord(token.value) -> {\n                parseIdDefine(token)\n            }\n            else -> throw ParseError(token)\n        }\n    }\n}"
        }
    ]
}